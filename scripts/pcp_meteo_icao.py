# -*- coding: utf-8 -*-
"""PCP-Meteo-ICAO

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l8xgl0Kt-N_FsBp9SESmN4wwayXF3SCb

#Exemplo de recolha de dados meteorológicos
Estágio, FEUP

1. Recolha de dados das condições meteorológicas do Aeroporto Francisco de Sá Carneiro

É importante revêr todo o código (incluindo os módulos que podem estar a ser importados mas não sejam usados), e reescrever de acordo com o PEP8 - [https://peps.python.org/pep-0008/][https://peps.python.org/pep-0008/].

For this type of straightforward script or pipeline, I prefer using plain code written sequentially, without wrapping it inside functions or classes. This approach improves readability and ease of understanding since the logic flows directly from top to bottom without abstraction layers. It also reduces unnecessary complexity and speeds up development for simple, linear tasks **where modularity and reuse are not critical**.

PCP, 8/11/2025
"""



## imports
##

import datetime
import json
import requests
import math

import socket
import os
from urllib.parse import quote

global enviro

current_env = os.environ.get('CONDA_DEFAULT_ENV')
print ("current_env", current_env)

if current_env is None:
  hostname=socket.gethostname()[:30]
  if hostname[:4]=="srv-":
    enviro="render"
    
  else:
    enviro="colab.google"
    from google.colab import userdata
else:
  enviro="to be defined"
  enviro="flask"

print ("current enviro:", enviro)


#if current_env is None:
#  ! pip install pymysql --quiet
#  ! pip install clts_pcp --quiet
#  ! pip install crate --quiet

import pymysql

import clts_pcp as clts
import crate
print("... done.")

current_env = os.environ.get('CONDA_DEFAULT_ENV')
print ("current_env:", current_env)
print ("enviro:", enviro)

## Context gathering

# clts profiling
tstart=clts.getts()

# Default configuration with alternatives documented
DEFAULT_PARAMS = {
    "verbose": True,           # alternatives: [True, False]
    "destination": "-*-",         # deprecated to use several alternatives: ['localhost', 'baze.cm-maia.pt', 'aiven'] - see below
    "send_mail": True,          # alternatives: [True, False]
    "email_addresses": ["pedroccpimenta@gmail.com", 'ppimenta.umaia@gmail.com' ]  # array of email addresses - alternatives: ['ppimenta@umaia.pt', 'ppimenta@cm-maia.pt']

    }

#
# NOTES:
#   - destination is to be deprecated by a list of destinations from this version on (check below)
#
# PCP, November 2025
#

# get hostanme of the machine where the script is running
hostname=socket.gethostname()[:30]


ip = requests.get('https://api.ipify.org').text

print("Server name:", hostname, "Public IP Address:", ip)


destination=DEFAULT_PARAMS['destination']
verbose= DEFAULT_PARAMS['verbose']
send_mail = DEFAULT_PARAMS['send_mail']
email_addresses = DEFAULT_PARAMS['email_addresses']



if '__file__' in globals():    # script running in airflow / Linux
  script_path = os.path.abspath(__file__)
  parts = __file__.replace('\\', "/").split('/')
  datapath=f'./data/ppimenta/{parts[-1]}'
  #enviro = "airflow/linux"

  script = parts[-1]
  channel = parts[-2]
  user = parts[-3]

  user = "PCP"

if False:   #  CHECK FOr AIRFLOW
  if '__file__' in globals():    # script running in airflow / Linux
    script_path = os.path.abspath(__file__)
    parts = __file__.replace('\\', "/").split('/')
    datapath=f'./data/ppimenta/{parts[-1]}'
    #enviro = "airflow/linux"
  else:                          # script running in colab.research.google
    enviro = "jupyter"
    #  !pip install ipynbname --quiet
    import ipynbname
    folder_path = os.getcwd()  # This returns the folder where the notebook is located
    print("folder_path:", folder_path)
    parts=[hostname, "pcp", "meteo data from ICAO" , ipynbname.name()]
    datapath="."
    destination=DEFAULT_PARAMS['destination']
    verbose= DEFAULT_PARAMS['verbose']
    send_mail = DEFAULT_PARAMS['send_mail']
    email_addresses = DEFAULT_PARAMS['email_addresses']


  if enviro=="jupyter":
    clts.elapt[f"running <a href='https://colab.research.google.com/drive/{script.replace("fileId=","")}'>google colab notebook</a>"] = clts.deltat(tstart)
  elif enviro=="render":
    print ("running in ", enviro, ", hostname:", hostname)
    pass
  else:
    # Try to retrieve airflow variable
    try:
        clts.elapt[f"script filename:{script}"] = clts.deltat(tstart)
        clts.elapt[f"var name: {script.replace('.py', '')}"] = clts.deltat(tstart)
        #airflow_conf = json.loads(Variable.get(script.replace('.py', "")))
        #airflow_conf = json.loads(Variable.get("pcp_itecons_v25"))
        airflow_conf = Variable.get(script.replace('.py', ''), default_var={}, deserialize_json=True)
        clts.elapt[f"Params read from variable:{airflow_conf}"] = clts.deltat(tstart)
    except Exception as e:
        airflow_conf = {"status":f"error reading from {script.replace('.py', '')}"}
        clts.elapt[f"Error: {e}"] = clts.deltat(tstart)

    clts.elapt[f"After reading from airflow variable:{airflow_conf}"] = clts.deltat(tstart)

    # Merge with DEFAULT_PARAMS
    if True:
      print (f"Default config: {DEFAULT_PARAMS}")

    clts.elapt[f"Default params:{DEFAULT_PARAMS}"] = clts.deltat(tstart)    # Profiling, August 2025

    config = {**DEFAULT_PARAMS, **airflow_conf}
    print(f"Updated config: {config}")

    #clts.elapt[f"Updated params (1):{airflow_conf1}"] = clts.deltat(tstart)    # Profiling, August 2025
    clts.elapt[f"Updated params:{config}"] = clts.deltat(tstart)    # Profiling, August 2025

    verbose = config['verbose']
    destination = config['destination']
    send_mail = config['send_mail']
    email_addresses = config['email_addresses']

# The overall format of context should be:
# server (ip) | user | channel | file.py | database destination (to be deprecated)
context= f'{hostname} ({ip}) | {user} | {channel} | {script} | {destination}'

clts.setcontext(context)
now = str(datetime.datetime.now())[0:19]
hoje = now[:10]
if verbose:
  print ("conntext:", context)
  # clts.listtimes()

## Getting data from geonames
#
if hostname[:4]=="srv-":
    enviro="render"

if enviro == "google.colab":
  creds = json.loads(userdata.get(f"{user}-geonames.json"))
elif enviro == "render":
  print (" > loading", f"/etc/secrets/{user}-geonames.json")
  creds = json.load(open(f"/etc/secrets/{user}-geonames.json"))
else:
  print (" > loading", f"./secrets/{user}-geonames.json")
  creds = json.load(open(f"./secrets/{user}-geonames.json"))


print (creds['manifesto'])

url=f"http://api.geonames.org/weatherIcaoJSON?ICAO=LPPR&username={creds['key']}"

if enviro == "google_colab":
  pass
elif enviro == "render":
  datapath=f"static/data/{user}"
  print ("datapath", datapath)
else:
  datapath=f"data/{user}"
  print ("datapath", datapath)


# Data saved for observability purposes
filename=f'{datapath}/geonames-icao.txt'

if True:

  data_str = requests.get(url).text
  data = json.loads(data_str)

  clts.elapt[f"Data request successful!"] = clts.deltat(tstart)    # add an entry to elapt dictionary

  
  with open(filename, 'w') as sfh:
    sfh.write (data_str)
  clts.elapt[f"Data ({len(data_str)} bytes) saved to file `{filename}`"] = clts.deltat(tstart)
  print(data_str)
  data = json.loads(data_str)

else:
  data = json.load(open(filename))
  print (" DATA READ FROM FILE")
  clts.elapt[f"Data read from file `{filename}`"] = clts.deltat(tstart)

icao   = data['weatherObservation']['ICAO']
tstamp = data['weatherObservation']['datetime']
v=data['weatherObservation']

if verbose:
  print (icao, tstamp)


sql = ( f"insert into icao_obs ("
        f"hostsource, tstamp, icao, nome, temperatura, pressao, "
        f"humidade, observation, elevation, intensidadeVento, "
        f"Latitude, Longitude "
        f") values ( "
        f"'{hostname}', '{tstamp}', '{icao}', '{v["stationName"]}', {v["temperature"]}, {v["hectoPascAltimeter"]}, "
        f"{v["humidity"]}, '{v["observation"]}', {v["elevation"]}, {v["windSpeed"]}, "
        f"{v['lat']}, {v['lng']} "
        f")"
)

if verbose:
    print (f'sql:{sql}')

"""# Conexão e Upsert na(s) base(s) de dados

Para cada tupo (`user`, `base de dados`), deverá haver um ficheiro de credenciais do tipo:

```
{
	"manifesto":"text describing the credencials",
	"filename":"<redundant>",
	"dest_host":"conection url to the database",
	"username":"username",
	"password":"password",
	"database":"database",
	"port":12345678,
	"burl4api": "base url of the api exposing the data",
	"timeout":20,
	"dbms":"dmbs type"
}
```

These credentials are to be uploaded to the `secrets` area.



Para a base de dados https://tidbcloud.com/ , o método de conexão exige TLS, o que obriga a que as credenciais sejam distintas:

```
{
	"manifesto":"Credentials for TIDB - ppimenta_umaia",
	"ConnectionString":"mysql://<username>:<PASSWORD>@gateway01.eu-central-1.prod.aws.tidbcloud.com:4000/datalake",
	"filename":"pcp-tidb_ppimenta_umaia.json",
	"dest_host":"gateway01.eu-central-1.prod.aws.tidbcloud.com",
	"username":"<username>",
	"database":"<database>",
	"port":4000,
	"pem":"pcp-tidb_ppimenta_umaia.pem",
	"password":"<password>",
	"timeout": 20,
	"burl4api": "https://spirale.onrender.com/api?",
	"dbms":"sql_tls"
}
```

e seja disponibilizado tb o ficheiro `pcp-tidb_ppimenta_umaia.pem`:

"""

# The script have to be parametrized by 'User' (so the script could be portable between users)
#
clts.elapt[f"Starting database accesses:"] = clts.deltat(tstart)

# Esta variável foi definida no início da execução desta notebook
# user = "pcp"  # Outras alternativas podem ser gmartins, mlbaltar, rmendes, ...

# dblist=json.loads(open(f"{user}-dblist.json")) # each user might use different destination databases
# This connection needs further parametrization, since the same user might want to use
# different databases for different pipelines / data sources
#
if enviro == "google.colab":
  dblist=json.loads(userdata.get(f"{user}-dblist.json"))
elif enviro == "render":
  dblist=json.load(open(f"/etc/secrets/{user}-dblist.json"))
else:
  dblist = json.load(open(f"secrets/{user}-dblist.json"))


print(dblist)

for db in dblist:
    status="nok"
    clts.elapt[f"Connecting to `{db}`"] = clts.deltat(tstart)
    if verbose:
      print ("db in dblist:", db)
      print (f'connecting to `{db}`')
    try:
      if enviro == "google.colab":
        dbcreds=json.loads(userdata.get(f'{user}-{db}.json'))
      elif enviro == "render":
        print ("READING ", f'/etc/secrets/{user}-{db}.json')
        dbcreds=json.load(open(f'/etc/secrets/{user}-{db}.json'))
        
      else:
        print ("READING ", f'secrets/{user}-{db}.json')
        dbcreds=json.load(open(f'secrets/{user}-{db}.json'))
        print("dbcreds:", dbcreds)


      if dbcreds['dbms']=="sql":
        print("... connecting to sql database...")
        timeout = dbcreds['timeout']

        connection = pymysql.connect(
            host=dbcreds["dest_host"],
            port=dbcreds["port"],
            db=dbcreds['database'],
            user=dbcreds['username'],
            password=dbcreds['password'],
            cursorclass=pymysql.cursors.DictCursor,
            charset="utf8mb4",
            connect_timeout=timeout,
            write_timeout=timeout,
            read_timeout=timeout
        )
        cursor = connection.cursor()
        clts.elapt[f"... connected to `{db}`"] = clts.deltat(tstart)
        status="ok"
        status="ok"

      elif dbcreds['dbms']=="sql_tls":
        print(f"... connecting to sql_tls database @{enviro}")
        timeout = dbcreds['timeout']
        if enviro =="google.colab":
          pem_content = userdata.get(dbcreds['pem'])

          with open(f'/tmp/{user}.pem', 'w') as f:
            f.write(pem_content)
          connection = pymysql.connect(
            host=dbcreds["dest_host"],
            port=dbcreds["port"],
            db=dbcreds['database'],
            user=dbcreds['username'],
            password=dbcreds['password'],
            cursorclass=pymysql.cursors.DictCursor,
            charset="utf8mb4",
            ssl={'ca': f'/tmp/{user}.pem'},
            connect_timeout=timeout,
            write_timeout=timeout,
            read_timeout=timeout,
            autocommit=True
        )
        elif enviro == "render":
          print ("Reading", f'/etc/secrets/{dbcreds['pem']}')
          pem_content = open (f'/etc/secrets/{dbcreds['pem']}').read()
          connection = pymysql.connect(
            host=dbcreds["dest_host"],
            port=dbcreds["port"],
            db=dbcreds['database'],
            user=dbcreds['username'],
            password=dbcreds['password'],
            cursorclass=pymysql.cursors.DictCursor,
            charset="utf8mb4",
            ssl={'ca': f'/etc/secrets/{user}.pem'},
            connect_timeout=timeout,
            write_timeout=timeout,
            read_timeout=timeout,
            autocommit=True
        )


        else:
          print ("Reading", f'secrets/{dbcreds['pem']}')
          pem_content = open (f'secrets/{dbcreds['pem']}').read()
          connection = pymysql.connect(
            host=dbcreds["dest_host"],
            port=dbcreds["port"],
            db=dbcreds['database'],
            user=dbcreds['username'],
            password=dbcreds['password'],
            cursorclass=pymysql.cursors.DictCursor,
            charset="utf8mb4",
            ssl={'ca': f'secrets/{user}.pem'},
            connect_timeout=timeout,
            write_timeout=timeout,
            read_timeout=timeout,
            autocommit=True
        )



        #cursor=connection.cursor()
        cursor = connection.cursor()
        clts.elapt[f"... connected to `{db}`"] = clts.deltat(tstart)
        status="ok"
      elif dbcreds['dbms']=="crate":
        # import crate
        print("... connecting to crate database...")
        from crate import client
        connection = client.connect(
            dbcreds["dest_host"],
            username=dbcreds['username'],
            password=dbcreds['password'],
            verify_ssl_cert=True
        )

        sql = ( f"insert into icao_obs ("
        f"id, hostsource, tstamp, icao, nome, temperatura, pressao, "
        f"humidade, observation, elevation, intensidadeVento, "
        f"Latitude, Longitude "
        f") values ( "
        f"1,'{hostname}', '{tstamp}', '{icao}', '{v["stationName"]}', {v["temperature"]}, {v["hectoPascAltimeter"]}, "
        f"{v["humidity"]}, '{v["observation"]}', {v["elevation"]}, {v["windSpeed"]}, "
        f"{v['lat']}, {v['lng']} "
        f")"
)


        cursor = connection.cursor()
        clts.elapt[f"... connected to `{db}`"] = clts.deltat(tstart)
        status="ok"
      elif dbcreds['dbms']=="mongobd":
        clts.elapt[f"... mongodb dmbs not ready "] = clts.deltat(tstart)
        status='onerror'
        pass
      else:
        clts.elapt[f"... `{dbcreds['dbms']}` dmbs not ready "] = clts.deltat(tstart)
        status='onerror'
        pass
      status="ok"
    except Exception as e:
      print("Error:", e)
      clts.elapt[f"... error `{e}` "] = clts.deltat(tstart)
      status='onerror'
      print ("status", status)
      exit(1)

    print ("status:", status)
    if status=='ok':
      sql_c =f"select count(*) as nr from icao_obs where tstamp = '{tstamp}' and icao = '{icao}';"
      if verbose:
        print(sql_c)

      cursor.execute(sql_c)
      res=cursor.fetchone()
      print('res:', res)
      if dbcreds['dbms']=="crate":
        a={}
        a['nr']= res[0]
        res= a
      print(res)
      if res["nr"]==0:
        cursor.execute(sql)
        connection.commit()
        clts.elapt[f"... `{tstamp}` inserted for {icao} @ {db} "] = clts.deltat(tstart)
      elif res["nr"]==1:
        clts.elapt[f"... `{tstamp}` for {icao} already persisted @ {db} "] = clts.deltat(tstart)
      else:
        status=f"duplicates"
        clts.elapt[f"... duplicates for `{icao}` @ `{tstamp}` @ {sb}  "] = clts.deltat(tstart)
    else:
      pass

    print ("Connection closing....")
    connection.close()

"""# Sending tasks summary by email

In order to send email (smtp / SSL @ gmail), a last credentials file is needed, in the form:

```
{
	"manifesto":"text describing the credencials.",

	"UserName":"username",
	"UserFrom":"email address",

	"UserPwd":"password"
}
```

Again, the filename of this file could be parametrized as <user>-<email service> or <user>-<email service>-<hostname> - to be discussed.

"""

# Envia email

clts.elapt["Overall (before email):"]=clts.deltat(tstart)
hora=str(datetime.datetime.now())[11:13]
horaemail=['07', '17' ]

#if sendmail and (hora in horaemail):  
if send_mail and email_addresses!=[]:
#if send_mail and  email_addresses!=[] and abs((datetime.datetime.now() - datetime.datetime.combine(datetime.datetime.now().date(), datetime.time(11, 0))).total_seconds() / 60) < 40 :

  if enviro=="render":

    from mailersend import MailerSendClient, EmailBuilder
      credsgmail=json.load( open("/etc/secrets/PCP-mailersend.json" ))
      ms = MailerSendClient( api_key=credsgmail['token'])

      text = toem+"\nEsta é uma mensagem automática."

      html = "<html><body style=''font-family:Montserrat;''>"+toem+ "<hr color=orange>"
      html = html +"This message is an automated notification from "+ context +"</body></html>"


      for em in email_addresses:
        email = (EmailBuilder()
         .from_email(credsgmail['user'], credsgmail['username'])
         .to_many([{"email": em, "name": em}  ])
         .subject(f"🌦️🛫 {context}")
         .html(html)
         .text("Hello World!")
         .build())

  else:
    toem=clts.listtimes()

    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart
    import smtplib, ssl

    # V25
    print (" AGAIN enviro:", enviro, "em hostname:", hostname)
    if enviro=="jupyter":
      credsgmail=json.loads(userdata.get('configGMail_PCP.json') )
    else:
      epath=""
      if enviro=="render":
          epath="/etc/"

      try:
          print("Trying to open " , f'{epath}secrets/configGMail_{hostname}.json')
          with open(f'{epath}secrets/configGMail_{hostname}.json', 'r') as fh:
              credsgmail=json.loads(fh.read())
      except Exception as err:
        print ("Error:", err)


    try:
        assunto = f"🌦️🛫 {context}"

        message = MIMEMultipart("alternative")
        message["Subject"] = assunto

        message["From"]=credsgmail['UserFrom']
        message["To"]=", ".join(email_addresses)
        message["Reply-To"]="ppimenta@ipmaia.pt"

        text = toem+"\nEsta é uma mensagem automática."

        html = "<html><body style=''font-family:Montserrat;''>"+toem+ "<hr color=orange>"
        html = html +"This message is an automated notification from "+ context +"</body></html>"

        # Turn these into plain/html MIMEText objects
        part1 = MIMEText(text, "plain")
        part2 = MIMEText(html, "html")

        # Add HTML/plain-text parts to MIMEMultipart message
        # The email client will try to render the last part first
        message.attach(part1)
        message.attach(part2)

        port=465 # SSL

        # Create a secure SSL context
        ssl_context = ssl.create_default_context()

        with smtplib.SMTP_SSL("smtp.gmail.com", port, context=ssl_context) as server:
          server.login(credsgmail['UserName'], credsgmail['UserPwd'])
          sender_email = credsgmail['UserFrom']
          server.sendmail(sender_email,email_addresses, message.as_string())
        print ("Notificação enviada.")
        clts.elapt[f"After sending email"] = clts.deltat(tstart)        # add an entry to elapt dictionary
    except Exception as e:
        print('A notificação não foi enviada:', e)
        clts.elapt[f"email not sent ({e})"] = clts.deltat(tstart)       # add an entry to elapt dictionary
    finally:
        pass